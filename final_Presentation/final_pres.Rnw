\documentclass{beamer}
\usetheme[compress]{Singapore}
\usepackage{german}
\usepackage[utf8]{inputenc}
\usepackage{adjustbox}
\usepackage{color}
\usepackage{amsbsy}
\setbeamertemplate{navigation symbols}{}
\makeatletter
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=2ex,center]{author in head/foot}%
    \usebeamerfont{author in
head/foot}%
  \insertshortauthor\hspace{1em}\beamer@ifempty{\insertshortinstitute}{}{(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=2ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=2ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\begin{document}
\SweaveOpts{concordance=TRUE}

<< include=F >>=

require(ggplot2);require(reshape2);require(colorspace);require(gridExtra);require(scales)
require(rgdal);require(rgeos);require(sp);require(maptools);require(rvest)
require(ggmap);require(dplyr);require(gstat)#;require(raster) # package loading


colo <- diverge_hsv(3)
get_legend<-function(myggplot){
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

# Einladen der Daten
bearbeiter <- 'Alex'
if(bearbeiter == 'Alex') {
  dataS <- read.csv2('/home/alex/Schreibtisch/Uni/statistisches_praktikum/Auswertung/Neue_Daten/Stuttgart21_aufbereitet.csv')
  bezirke <- readOGR(dsn = "/home/alex/Schreibtisch/Uni/statistisches_praktikum/Auswertung/Geodaten/bezirke", layer = "bezirke")
  Stadtteile <- readOGR(dsn = "/home/alex/Schreibtisch/Uni/statistisches_praktikum/Daten_Kneib/Stick/Daten_Kneib/Stadtteile_netto/", layer = "Stadtteile_netto")
  count_u_cs <- read.csv2('/home/alex/Schreibtisch/Uni/statistisches_praktikum/Presi/Statistical-Practical/count_u_cs.csv')
  count_z_cs <- read.csv2('/home/alex/Schreibtisch/Uni/statistisches_praktikum/Presi/Statistical-Practical/count_z_cs.csv')
} else {
  dataS <- read.csv2('/home/khusmann/mnt/U/Promotion/Kurse/Stat_Praktikum/Auswertung/Neue_Daten/Stuttgart21_aufbereitet.csv')
}
@

\title{Kleinräumige extrapolation von Umfragedaten}   
\author{Kai Husmann, Alexander Lange} 
\institute{Georg-August-Universität Göttingen}
\date{\today}

{
\setbeamertemplate{footline}{} 
\begin{frame}
\titlepage
\end{frame}
}
\addtocounter{framenumber}{-1}

\begin{frame}
\frametitle{Inhaltsverzeichnis}\tableofcontents
\end{frame}

\section{Einleitung}
\begin{frame}\frametitle{Einleitung} 
\begin{itemize}
\item Daten zur Bevölkerungsstruktur Stuttgarts
\item Nur Informationen aus der Stichrobe enthalten, \underline{keine} Grundgesamtheit aus dieser Erhebung verfügbar
\item Hochrechnung der Informationen mithilfe der Grundgesamtheiten aus \underline{anderen} Erhebungen (Bürgerumfrage und Zensus)
\item Brücksichtigung von unterschiedlichen räumlichen Effekten
\item Ziel: Extrapolation der Informationen aus der Stichprobe und Möglichkeit der Validierung finden
\end{itemize}
\end{frame}

\section{Deskriptive Statistik}
\subsection{Datensatz}

\begin{frame}\frametitle{Datensatz}
\begin{table}
\centering
\adjustbox{max height=\dimexpr\textheight-5.5cm\relax,
           max width=\textwidth}{
\begin{tabular}{l|c|c}
\multicolumn{2}{l}{Anzahl Beobachtungen Stichprobe: 3.143}     \\ \hline \hline
\textbf{Variable} & \textbf{Anzahl Klassen} & \textbf{Modellierung} \\ \hline
\textcolor{blue}{Bewertung Wohngegend} &  \textcolor{blue}{6} & \textcolor{blue}{Geordnet Kategorial} \\ \hline
\textcolor{blue}{Meinung Stuttgart 21} &  \textcolor{blue}{6} & \textcolor{blue}{Geordnet Kategorial} \\ \hline
Personenanzahl im Haushalt & 5 & Nicht Parametrisch \\ \hline
\textcolor{red}{Monatliches Netto Haushaltseinkommen} & \textcolor{red}{6} & \textcolor{red}{Nicht Parametrisch} \\ \hline
Altersklasse Befragter & 6 & Nicht Parametrisch \\ \hline
Geschlecht & 2 & Parametrisch\\ \hline
Familienstand & 4 & Parametrisch \\ \hline
Nationalität & 2 & Parametrisch \\ \hline
Stadtbezirk & 23 & Diskret Räumlich \\ \hline 
Stadtteil &  142 & Diskret Räumlich \\ \hline 
Gauß-Krüger & & Stetig Räumlich  \\ \hline \hline
\end{tabular}
}
\end{table}
\end{frame}

\begin{frame}\frametitle{Response Variablen}
<<echo=F, fig.width='7cm', fig.height=4.5, fig.align='center'>>=
# Creating Bar plots of Variables
# counting frequencies
theme_set(theme_bw(10))
count1 <- as.data.frame(table(dataS$Bewertung.Wohngegend))
count2 <- as.data.frame(table(dataS$Meinung.zu.Stuttgart.21))

# rearranging of groups
count1$Var1 <- c('S. gut', 'Gut', 'Neutral', 'Schlecht', 
                 'S. schlecht', 'K. Angabe')
count1$Var1 <- factor(count1$Var1, levels = c('S. gut', 'Gut', 'Neutral', 'Schlecht', 
                                                          'S. schlecht', 'K. Angabe'))
count2$Var1 <- c('S. gut', 'Gut', 'Neutral', 'Schlecht', 
                 'S. schlecht', 'K. Angabe')
count2$Var1 <- factor(count2$Var1, levels = c('S. gut', 'Gut', 'Neutral', 'Schlecht', 
                                              'S. schlecht', 'K. Angabe'))
count1$stat <- 'Bewertung Wohngegend Original'
count2$stat <- 'Meinung Stuttgart 21 Original'
cc <- rbind(count1, count2)

# Plotting  
plot1 <- ggplot(cc, aes(x = Var1, y = Freq)) + 
               geom_bar(stat="identity", position=position_dodge(), col = 'black', alpha = .5, fill = colo[1]) +
               labs(x = NULL, y = 'Häufigkeit')  + facet_wrap(~ stat) 

dataC <- dataS
for(i in 1:nrow(dataC)){
  if(dataC$Meinung.zu.Stuttgart.21[i] == 6){
    dataC$Meinung.zu.Stuttgart.21[i] <- NA
  }}
dataC <- na.omit(dataC)
for(i in 1:nrow(dataC)){
  if(dataC$Bewertung.Wohngegend[i] == 6){
    dataC$Bewertung.Wohngegend[i] <- NA
  }}
dataC <- na.omit(dataC)
# Zusammenführen von 'Sehr gut' und 'Gut' zu Zustimmung und 'Sehr Schlecht' und 'Schlecht' zu Ablehnend 
for(i in 1:nrow(dataC)){
  if(dataC$Meinung.zu.Stuttgart.21[i] == 2){
    dataC$Meinung.zu.Stuttgart.21[i] <- 1
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Meinung.zu.Stuttgart.21[i] == 3){
    dataC$Meinung.zu.Stuttgart.21[i] <- 2
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Meinung.zu.Stuttgart.21[i] == 4){
    dataC$Meinung.zu.Stuttgart.21[i] <- 3
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Meinung.zu.Stuttgart.21[i] == 5){
    dataC$Meinung.zu.Stuttgart.21[i] <- 3
  }}

for(i in 1:nrow(dataC)){
  if(dataC$Bewertung.Wohngegend[i] == 2){
    dataC$Bewertung.Wohngegend[i] <- 1
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Bewertung.Wohngegend[i] == 3){
    dataC$Bewertung.Wohngegend[i] <- 2
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Bewertung.Wohngegend[i] == 4){
    dataC$Bewertung.Wohngegend[i] <- 3
  }}
for(i in 1:nrow(dataC)){
  if(dataC$Bewertung.Wohngegend[i] == 5){
    dataC$Bewertung.Wohngegend[i] <- 3
  }}

count1 <- as.data.frame(table(dataC$Bewertung.Wohngegend))
count2 <- as.data.frame(table(dataC$Meinung.zu.Stuttgart.21))
# rearranging of groups
count1$Var1 <- c('Zustimmung', 'Neutral', 'Ablehnung')
count1$Var1 <- factor(count1$Var1, levels = c('Zustimmung', 'Neutral',  
                 'Ablehnung'))
count2$Var1 <- c('Zustimmung', 'Neutral', 
                 'Ablehnung')
count2$Var1 <- factor(count2$Var1, levels = c('Zustimmung', 'Neutral', 
                 'Ablehnung'))
count1$stat <- 'Bewertung Wohngegend Transformiert'
count2$stat <- 'Meinung Stuttgart 21 Transformiert'
cc <- rbind(count1, count2)
# Plotting  
plot2 <- ggplot(cc, aes(x = Var1, y = Freq)) + 
               geom_bar(stat="identity", position=position_dodge(), col = 'black', alpha = .5, fill = colo[1]) +
               labs(x = NULL, y = 'Häufigkeit')  + facet_wrap(~ stat) 

grid.arrange(plot1, plot2, ncol = 1)
@
\end{frame}

\subsection{Räumliche Effekte}
\begin{frame}\frametitle{Gauss-Krüger Informationen}
<<echo=F, fig.width='8cm', fig.height=5, fig.align='center', message=F, warning=F>>=
# selcting variables of interest
myvar <- c('Meinung.zu.Stuttgart.21', 'X', 'Y')
ST22 <- dataS[myvar]
ST21 <- ST22
# numerical classes into factor classes
ST21$Meinung.zu.Stuttgart.21 <- ''
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 1] <- 'Sehr gut'
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 2] <- 'Gut'
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 3] <- 'Neutral'
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 4] <- 'Schlecht'
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 5] <- 'Sehr schlecht'
ST21$Meinung.zu.Stuttgart.21[ST22$Meinung.zu.Stuttgart.21 == 6] <- 'Keine Angabe'
# assigning names
names(ST21) <- c('Meinung', 'long', 'lat') 
ST21$long <- as.numeric(as.character(ST21$long))
ST21$lat <- as.numeric(as.character(ST21$lat))
# transform to spatial class
coordinates(ST21) <- ~ long + lat
# assign CRS
proj4string(ST21) <- CRS("+init=epsg:31467")
# reproject data
ST21 <- spTransform(ST21, CRS("+proj=longlat +datum=WGS84"))
# loading map
map <- get_map(location= rowMeans(bbox(ST21)), zoom=11, maptype = 'terrain', scale = 2)
# transform back to data frame for ggplot
ST21.g <- as.data.frame(ST21)

bezirke.t <- spTransform(bezirke, CRS("+proj=longlat"))
# getting ratings
S3 <- ST21.g[which(ST21.g$Meinung=='Sehr gut' | ST21.g$Meinung=='Gut'),]
S32 <- ST21.g[which(ST21.g$Meinung=='Neutral'),]
S4 <- ST21.g[which(ST21.g$Meinung=='Schlecht' | ST21.g$Meinung=='Sehr schlecht'),]

# erstellen des neuen data frames
S3$Meinung <- 'Zustimmung'
S4$Meinung <- 'Ablehnung'
data.facet <- rbind(S3, S32, S4)
data.facet$Meinung <- factor(data.facet$Meinung, levels = c('Zustimmung', 'Neutral', 'Ablehnung'))

# Plotting map
ggmap(map, extent = 'device', legend = 'topright') + geom_polygon(data=bezirke.t, aes(x=long, y=lat, group=group),colour="black", alpha=0) +
  stat_density2d(
    aes(x = long, y = lat, fill = ..level..,  alpha = ..level..),
    size = 2, bins = 8, data = data.facet,
    geom = "polygon"
  ) +
  theme_bw(10) +
  theme(axis.line=element_blank(),
      axis.text.x=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank(),
      legend.position = 'bottom') +
  scale_fill_gradient(low=colo[2], high = 'darkblue')+
  scale_alpha(range = c(0.5,0.9), guide=FALSE) +
  labs(fill = 'Dichte') +
  xlim(9.035, 9.32) + ylim(48.69, 48.87) +
  facet_wrap(~ Meinung, nrow = 1)
@
\end{frame}

\begin{frame}\frametitle{Diskrete Informationen zu Stadtbezirken}
<<echo=F, fig.width='8cm', fig.height=5, fig.align='center', message=F, warning=F>>=
# selcting variables of interest
myvar <- c('Meinung.zu.Stuttgart.21', 'Stadtbezirk', 'X', 'Y')
ST <- dataS[myvar]
# Ermittlung der Zustimmung in den Stadtteilen ('Sehr gut')
beob.bez <- as.data.frame(table(ST$Stadtbezirk))
meinung.bez <-as.data.frame(table(ST$Stadtbezirk, ST$Meinung.zu.Stuttgart.21))
# Relative Anteile 
SG <- ((meinung.bez$Freq[1:23] + meinung.bez$Freq[24:46]) /beob.bez$Freq)*100
SGA <- as.data.frame(cbind(as.character(beob.bez$Var1), SG))
SGA$Meinung <- as.factor('Zustimmung')
N <- (meinung.bez$Freq[47:69]/beob.bez$Freq)*100
N.A <- as.data.frame(cbind(as.character(beob.bez$Var1), N))
N.A$Meinung <- as.factor('Neutral')
S <- ((meinung.bez$Freq[70:92] + meinung.bez$Freq[93:115])/beob.bez$Freq)*100
SA <- as.data.frame(cbind(as.character(beob.bez$Var1), S))
SA$Meinung <- as.factor('Ablehnung')


# ID variable erzeugen um Data Frame und Spatial object zu verbinden
bezirke@data$id <- rownames(bezirke@data)
watershedPoints <- fortify(bezirke, region = "id")

# Errechneten Anteile und räumliche Informationen verbinden
bb <- merge(watershedPoints, bezirke@data, by = 'id', all.x = T)
colnames(SGA) <- c('STADTBEZIR', 'anteil', 'Meinung')
colnames(N.A) <- c('STADTBEZIR', 'anteil', 'Meinung')
colnames(SA) <- c('STADTBEZIR', 'anteil', 'Meinung')
bbSGA <- merge(bb, SGA, by = 'STADTBEZIR')
bbNA <- merge(bb, N.A, by = 'STADTBEZIR')
bbSA <- merge(bb, SA, by = 'STADTBEZIR')

# erstellen des neuen data Frames
b.facet <- rbind(bbSGA, bbNA, bbSA)
b.facet$anteil <- as.numeric(as.character(b.facet$anteil))

# Sortieren damit Poylogene richtig geplottet werden
b.facet <- b.facet[order(b.facet$order),]

# Plotten 
ggplot(data=b.facet, aes(x=long, y=lat, group=group, fill = anteil, alpha = anteil))+  
  geom_polygon(color = "black") +
  labs(x=NULL, y=NULL, title= NULL) +
  scale_fill_gradient(name = "Anteil in %", low = colo[2], high = 'darkblue', guide = "colorbar",
                      breaks = pretty_breaks(n = 5)) +
  scale_alpha(range = c(0.3,1), guide=FALSE) +
  coord_equal(1)+
  theme_bw(10) +
  theme(
    legend.position = 'bottom'
    ,axis.text.x=element_blank()
    ,axis.text.y=element_blank()
    ,axis.ticks.y=element_blank()
    ,axis.ticks.x=element_blank()
  ) + facet_wrap(~ Meinung)
@
\end{frame}

\begin{frame}\frametitle{Diskrete Informationen zu Stadtteilen}
<<echo=F, fig.width='8cm', fig.height=5, fig.align='center', message=F, warning=F>>=
# selcting variables of interest
myvar <- c('Meinung.zu.Stuttgart.21', 'Stadtteil', 'X', 'Y')
ST <- dataS[myvar]

# Ermittlung der Zustimmung in den Stadtteilen
beob.teile <- as.data.frame(table(ST$Stadtteil))
meinung.teile <-as.data.frame(table(ST$Stadtteil, ST$Meinung.zu.Stuttgart.21))

# Anteile berechnen 
Zustimmung <- ((meinung.teile$Freq[1:141] + meinung.teile$Freq[142:282])/beob.teile$Freq)*100
Zustimmung.a <- as.data.frame(cbind(as.character(beob.teile$Var1), Zustimmung))
Zustimmung.a$Meinung <- as.factor('Zustimmung')
Neutral <- ((meinung.teile$Freq[283:423])/beob.teile$Freq)*100
Neutral.a <- as.data.frame(cbind(as.character(beob.teile$Var1), Neutral))
Neutral.a$Meinung <- as.factor('Neutral')
Ablehnung <- ((meinung.teile$Freq[424:564] + meinung.teile$Freq[565:705])/beob.teile$Freq)*100
Ablehnung.a <- as.data.frame(cbind(as.character(beob.teile$Var1), Ablehnung))
Ablehnung.a$Meinung <- as.factor('Ablehnung')

# ID variable erzeugen um objecte zu verbinden
Stadtteile@data$id <- rownames(Stadtteile@data)
watershedPoints <- fortify(Stadtteile, region = "id")

# Data Frame und Spatial object verbinden
bbs <- merge(watershedPoints, Stadtteile@data, by = 'id', all.x = T)
colnames(Zustimmung.a) <- c('STADTTEIL', 'anteil', 'Meinung')
colnames(Neutral.a) <- c('STADTTEIL', 'anteil', 'Meinung')
colnames(Ablehnung.a) <- c('STADTTEIL', 'anteil', 'Meinung')
bbz <- merge(bbs, Zustimmung.a, by = 'STADTTEIL', all.x = T)
bbn <- merge(bbs, Neutral.a, by = 'STADTTEIL', all.x = T)
bba <- merge(bbs, Ablehnung.a, by = 'STADTTEIL', all.x = T)
s.facet <- rbind(bbz, bbn, bba)
s.facet$anteil <- as.numeric(as.character(s.facet$anteil))

# Sortieren um polygone richtig zu plotten
s.facet <- s.facet[order(s.facet$order),]
pol.na <- filter(s.facet, is.na(Meinung))
plo.na <- select(pol.na, STADTTEIL, id, long, lat, order, group)
s.facet <- na.omit(s.facet)

ggplot() +  geom_polygon(data = plo.na, aes(x = long, y = lat, group = group), fill = 'black') +
  geom_polygon(data=s.facet, aes(x=long, y=lat, group=group, fill = anteil, alpha = anteil), color = "black") +
  labs(x=NULL, y=NULL, title=NULL) +
  scale_fill_gradient(name = "Anteil in %", low = colo[2], high = 'darkblue', guide = "colorbar", na.value="black",
                       breaks = pretty_breaks(n = 5)) +
  scale_alpha(range = c(0.3,1), guide=FALSE) +
  coord_equal(1)+
  theme_bw(10) +
  theme(
    legend.position = 'bottom'
    ,axis.text.x=element_blank()
    ,axis.text.y=element_blank()
    ,axis.ticks.y=element_blank()
    ,axis.ticks.x=element_blank()
  ) + facet_wrap(~Meinung, nrow = 1)
@
\end{frame}

\section{Methodik}
\subsection{Model}

\begin{frame}\frametitle{Modellierung}
\textbf{Generalisierte additive Modelle}
\begin{itemize}
\item Einbindung von parametrischen Effekten durch linearen Schätzer
\item Einbindung von nicht-parametrischen Effekten über P-Splines
\item Stetige räumliche Gauss-Krüger Effekte mit Tensorprodukt-Spline
\item Diskrete räumliche Effekte durch Gauss-Markov Zufallsfeld 
\end{itemize}
$$
P(y_i = r) = \beta_0+ \textbf{x}'\pmb{\beta} + f(\textbf{z}) + räumlich = \begin{cases} 
f(s_x,s_y) \\
f(s_{Stadtteil}) \\
f(s_{Stadtbezirk})
\end{cases} + \varepsilon
$$
Insgesamt 6 Modelle zu schätzen
\end{frame}

\subsection{Modellwahl}

\begin{frame}\frametitle{Modellwahl}
\textbf{AIC-Basierte schrittweise Modellwahl}
\begin{itemize}
\item Vorab Einschätzen, ob Variablen parametrisch oder nichtparametrisch eingehen sollen
\item Potenziell nichtparametrische Variablen werden auch parametrisch getestet
\item Räumliche Variablen gehen als feste Modellbestandteile ein
\item Sinnvoll erscheinende Wechselwirkungen werden händisch untersucht
\end{itemize}

Insgesamt 6 Modelle zu schätzen
\end{frame}

\subsection{Modellvalidierung}
\begin{frame}\frametitle{Modellvalidierung}
\textbf{Kreuzvalidierung}
\begin{itemize}
\item Es liegt keine Grundgesamtheit vor
\item Das beste Modell wird mit einer Zufallsauswahl neu parameterisiert
\item Alle Datensätze werden vorhergesagt
\item Interpretation der Confusion Matrix
\end{itemize}

\section{Ergbenisse}
\subsection{GAM Schätzung}

\subsection{Prediction}
\begin{frame}\frametitle{Prediction}
<<echo=F, fig.width='8cm', fig.height=5, fig.align='center', message=F, warning=F>>=
tt <- c(2, 0)
count_u_cs <- rbind(count_u_cs, tt)
count_u_cs$Var1 <- c('Zustimmung', 'Ablehnung', 'Neutral')
count_u_cs$Var1 <- factor(count_u_cs$Var1, levels = c('Zustimmung', 'Neutral','Ablehnung'))
count_u_cs$Freq <- count_u_cs$Freq/sum(count_u_cs$Freq)

count_z_cs <- rbind(count_z_cs, tt)
count_z_cs$Var1 <- c('Zustimmung','Ablehnung', 'Neutral')
count_z_cs$Var1 <- factor(count_z_cs$Var1, levels = c('Zustimmung', 'Neutral','Ablehnung'))
count_z_cs$Freq <- count_z_cs$Freq/sum(count_z_cs$Freq)

count_u_cs$stat <- 'Extrapolation Bürgerumfrage'
count_z_cs$stat <- 'Extrapolation Zensus'
count2$Freq <- count2$Freq/sum(count2$Freq)
count2$stat <- 'Stichprobe'

cc2 <- rbind(count2, count_u_cs, count_z_cs)
ggplot(cc2, aes(x = Var1, y = Freq)) + 
               geom_bar(stat="identity", position=position_dodge(), col = 'black', alpha = .5, fill = colo[1]) +
               labs(x = NULL, y = 'Häufigkeit')  + facet_wrap(~ stat) 
@
\end{frame}

\end{document}